---
layout: post
title:  "Java中HashMap的实现"
date:   2017-03-08 23:06:05
categories: Java
tags: java HashMap 集合 基础
author: sqp
---

* content
{:toc}

>HashMap是java中常用的一种存储结构。其实现方式也十分巧妙，

## 数据结构
HaspMap采用了数组+链表的方式实现, 结构如下：
![avator](http://pf1gfkwtz.bkt.clouddn.com/18-9-15/87850200.jpg)  
HashMap初始化时会根据initCapacity（默认16）初始化一个定长数组即Hash桶的数量。新插入的entry根据key值计算hash值散落到不同的Hash桶中，如果桶是空的则初始化一个链表，插入的数据则作为链表中的头数据，此链表就是桶的概念；如果桶非空，则将entry追加到链表尾部。随着entry的不断插入，hash冲突会持续发生，当hashmap中的entry个数达到initCapacity的threshold（默认0.75）并且再次产生hash冲突的时候，hashmap会发生扩容，数组长度翻倍initCapacity = initCapacity * 2。如果扩容的同时发生插入或删除操作会造成数据错乱，所以hashmap是非线程安全的。

## 特性
1、基于哈希表的Map接口实现，使用链地址法处理hash冲突。如果hash函数绝对随机均匀，那么基本操作（get和put）的时间性能基本是恒定的。迭代操作所需的时间大致与HashMap的容量（hash桶的个数，table.length）和K-V对的数量（size）的 和 成正比，因此，如果迭代性能很重要，不要将初始容量设置得太高（或负载系数太低）。jdk1.8中新增如果key太多则用存储在红黑树种加快查找速度。  
2、HashMap有两个影响其性能的参数：初始容量initCapacity，和负载因子loadFactor。容量是哈希表中的hash桶的个数，initCapacity只是创建哈希表时的容量，loadFactor是衡量哈希表在扩容之前允许达到多少的量度。当哈希表中的条目数量超过loadFactor和当前容量capcity的乘积threshold时，哈希表会扩容为两倍的大小，并且进行重新散列（重建内部数据结构，各个K-V对重新存储到新的哈希表中）。
默认负载因子0.75在时间成本和空间成本之间提供了良好的平衡。较高的值loadFactor会减少空间开销，但会增加查找成本（反映在HashMap类的大多数操作中，包括get和put）。在设置其初始容量时，应考虑映射中的预期条目数（size）及其负载因子（loadFactor），提前设置好。这样能尽量节省空间，并且减少扩容次数，提高HashMap整体存储效率。  
3、允许null key和null value，null key总是放在第一个hash桶中。  
4、非同步，可以使用Collections.synchronizedMap包装下进行同步，这样具体实现还是使用HashMap的实现；也可以使用Hashtable，它的方法是同步的，但是实现上可能和HashMap有区别；多数场景下，可以使用ConcurrentHashMap。  
5、跟ArrayList一样，HashMap的迭代器是fail-fast迭代器。  
6、实现Cloneable接口，可clone。  
7、实现Serializable接口，可序列化/反序列化。  

>注意：  
有些博客里会说当hashmap容量第一次达到12的时候会发生扩容，其实不严谨，查询源码会发现扩容要桶时满足两个条件，即容量达到阈值并且发生hash冲突。所有在某些情况下，比如initCapacity=16，插入前11个元素都在hash桶的第一个位置，当插入第12个元素时散列到第二个hash桶，此时并不会发生扩容，如果后续的10个元素均散列到空的hash桶中也不会发生扩容。所有在initCapacity=16的haspmap中不发生扩容能插入的极限个数是11+15=26个。