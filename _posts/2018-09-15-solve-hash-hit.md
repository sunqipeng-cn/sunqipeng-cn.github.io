---
layout: post
title:  "解决Hash冲突的几种方式"
date:   2018-09-15 23:06:05
categories: 算法
tags: java Hash
author: sqp
---

* content
{:toc}

### 定义
>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 

Hash算法将长串散列为短串后，不同的长串可能会被散列为相同的输出，当两个值的散列值相同时，这两个值便产生了hash冲突，非常常见的比如Java中hashmap中存储entry时，两个key散列值相同会被放到同一个hash桶中，而java中采取的解决办法是在hash桶中维护一个链表，将hash值相同的entry通过链表连接起来，也就是下文介绍的链地址法。

处理Hash冲突的方法主要有以下几种：  

### 开放定址法： 

基本思想是，当产生哈希冲突时，即关键字key的地址p=hash(key)上已经有值了，那么这是以p为基础，产生另外一个哈希地址p1,如果p1不冲突了，那么就将元素key存在位置p1,如果p1也冲突，就计算hash(p1)=p2，不冲突就存在p2,冲突继续计算；  

再散列有几种方式：
1. 线性探测再散列：冲突发生时，查看下个位置是否空，然后遍历下去找到个空的地方存放；
2. 二次探测再散列：冲突发生时，在表的左右进行跳跃探测，di=12 -12 22 -22....k2 -k2;
3. 伪随机探测再散列：di=伪随机序列；

### 再哈希法

这种方法是同时构造多个不同的哈希函数：

Hi=RH1（key）  i=1，2，…，k

当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。

### 链地址法

这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。

### 建立公共溢出区

这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。


### 比较
总的来说有两种思路，一种在内部重新寻址，另一种在其他地点开辟新的内存存储。两种各有优缺点，具体场景应该具体判断。

#### 开放散列（open hashing）/ 链地址法（针对桶链结构）
1）优点：   
①对于记录总数频繁可变的情况，处理的比较好（也就是避免了动态调整的开销）  
②由于记录存储在结点中，而结点是动态分配，不会造成内存的浪费，所以尤其适合那种记录本身尺寸（size）很大的情况，因为此时指针的开销可以忽略不计了  
③删除记录时，比较方便，直接通过指针操作即可  
 
2）缺点：   
①存储的记录是随机分布在内存中的，这样在查询记录时，相比结构紧凑的数据类型（比如数组），哈希表的跳转访问会带来额外的时间开销。  
②如果所有的 key-value 对是可以提前预知，并之后不会发生变化时（即不允许插入和删除），可以人为创建一个不会产生冲突的完美哈希函数（perfect hash function），此时封闭散列的性能将远高于开放散列。  
③由于使用指针，记录不容易进行序列化（serialize）操作  

#### 封闭散列（closed hashing）/ 开放定址法

1）优点：  
 ①记录更容易进行序列化（serialize）操作  
 ②如果记录总数可以预知，可以创建完美哈希函数，此时处理数据的效率是非常高的
 
2）缺点：  
①存储记录的数目不能超过桶数组的长度，如果超过就需要扩容，而扩容会导致某次操作的时间成本飙升，这在实时或者交互式应用中可能会是一个严重的缺陷  
②使用探测序列，有可能其计算的时间成本过高，导致哈希表的处理性能降低  
③由于记录是存放在桶数组中的，而桶数组必然存在空槽，所以当记录本身尺寸（size）很大并且记录总数规模很大时，空槽占用的空间会导致明显的内存浪费  
④删除记录时，比较麻烦。比如需要删除记录a，记录b是在a之后插入桶数组的，但是和记录a有冲突，是通过探测序列再次跳转找到的地址，所以如果直接删除a，a的位置变为空槽，而空槽是查询记录失败的终止条件，这样会导致记录b在a的位置重新插入数据前不可见，所以不能直接删除a，而是设置删除标记。这就需要额外的空间和操作。